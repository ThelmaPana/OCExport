---
title: "Compute UVP diversity metrics"
format:
  html:
    toc: true
editor: visual
---

```{r}
#| output: false
#| warning: false
source("utils.R")
```

## Read UVP data

```{r}
load("data/02.all_uvp.Rdata")
```

## Clean data

### Depth

Keep only organisms above the depth at which we want to predict poc export, i.e. 1000 m.

```{r}
o <- o %>% filter(depth < max_depth_uvp)
```

### Taxa

List taxa, merge contextual observations with regular observations. Remove some unwanted taxa: tentacles of Cnidaria (only part of organisms, not representative of the overall morphology), Trichodesmium, Nostocales and Bacillariophyta (phytoplankton).

```{r}
# List of taxa
taxa <- o %>% pull(taxon) %>% unique() %>% sort()
taxa

# Merge contextual
o <- o %>% mutate(taxon = str_remove_all(taxon, " \\(contextual\\)")) # NB need to use \\

# List unwanted taxa
unwanted <- c("Bacillariophyta", "Nostocales", "tentacle of Cnidaria", "Trichodesmium")
o <- o %>% filter(!taxon %in% unwanted)

# New list of taxa
taxa <- o %>% pull(taxon) %>% unique() %>% sort()
taxa
```

### Profiles

Compute the number of objects per profile and keep only profiles that have more than `r n_min_uvp` objects.

-   [TODO: minimum number of objects to keep a profile?]{style="color: red;"} Plot it!

```{r}
profiles <- o %>% 
  group_by(profile_id, lon, lat, datetime) %>% 
  summarise(n_obj = n()) %>% 
  ungroup()

profiles %>% 
  ggplot() +
  geom_histogram(aes(x = n_obj), bins = 50) +
  scale_x_continuous(limits = c(0, 50)) #+
  #scale_y_continuous(trans = "log1p")
  #scale_y_log10()
```

Not obvious, but the minimum number of objects per profile cannot be under 3.

```{r}
#| fig-column: body-outset
#| out-width: 100%
profiles %>%
  ggplot() +
  geom_polygon(data = world, aes(x = lon, y = lat, group = group), fill = "gray") +
  geom_point(aes(x = lon, y = lat, colour = n_obj > n_min_uvp), size = 0.5) +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) +
  coord_quickmap()
```

```{r}
# Keep only profiles with enough objects
profiles <- profiles %>% filter(n_obj > n_min_uvp) %>% select(-n_obj)

# Drop objects that do not belong to these profiles
o <- o %>% filter(profile_id %in% profiles$profile_id)
```

We have `r nrow(o)` objects belonging to `r nrow(profiles)` profiles.

## Taxonomic diversity

Compute taxonomic diversity indices:

-   Taxonomic richness

-   Shannon Diversity

-   Pielou Evenness

```{r}
# Generate a contingency table as a matrix to feed to vegan
cont <- o %>%
  count(profile_id, taxon) %>%
  pivot_wider(names_from = "taxon", values_from = "n", values_fill = 0) %>%
  as.data.frame() %>%
  column_to_rownames(var = "profile_id") %>%
  as.matrix()

# Compute diversity metrics
ta_div_prof <- tibble(
  profile_id = rownames(cont),
  ta_ric = specnumber(cont),
  ta_shannon = diversity(cont, index = "shannon"),
  ta_pielou = ta_shannon/log(ta_ric)
) %>%
  left_join(profiles, by = join_by(profile_id)) %>%
  select(profile_id, lon, lat, everything())


# Store results with table of profiles
profiles <- profiles %>% left_join(ta_div_prof, by = join_by(profile_id, lon, lat, datetime))
```

Plot taxonomic diversity metrics.

```{r}
#| fig-column: body-outset
#| out-width: 100%
ggmap(
  profiles, 
  "ta_ric", 
  type = "point"
  )

ggmap(
  profiles, 
  "ta_shannon", 
  type = "point"
  )

ggmap(
  profiles, 
  "ta_pielou", 
  type = "point"
  )
```

## Trophic diversity

## Morphological diversity

Based on:

-   <https://github.com/jiho/ptb_morphodiv/tree/master>

-   [Beck et al. 2023](https://royalsocietypublishing.org/doi/full/10.1098/rspb.2023.2109)

### Features

Some features are not meaningful for the morphology and thus should be removed. Other features have a unique value for all individuals and other are missing for many individuals. Let’s remove them.

```{r}
# Select features
# NB this excludes ratio of features, e.g. kurt_mean which is kurt/mean
x <- o %>% select(area:circex)

# Remove variables with zero variance
feats <- x %>%
  summarise_all(var, na.rm = TRUE) %>%
  pivot_longer(cols = everything()) %>%
  filter(value > 0) %>%
  pull(name)

# Remove additional features that are relative to position within image
feats <- feats[!feats %in% c("angle", "tag", "centroids", "xmg5", "ymg5")]

x <- x %>% select(all_of(feats))
```

Plot features distributions.

```{r}
#| fig-column: screen-inset
#| out-width: 100%
#| #| fig-width: 10
#| fig-height: 8
x %>%
  pivot_longer(cols = everything()) %>%
  ggplot() +
  geom_histogram(aes(x = value), bins = 50) +
  facet_wrap(~name, scales = "free")
```

For a PCA, features should be normally-distributed. Let’s apply some transformation to get closer to normal distribution:

-   mask extreme values

-   normalize using the Yeo-Johnson transformation

-   replace missing values by the mean of each column

```{r}
x_norm <- x %>%
  # remove the most extreme high values
  mutate_all(mask_extreme, percent = c(0, 0.5)) %>%
  # normalise using the Yeo-Johnson transformation
  mutate_all(yeo_johnson) %>%
  mutate_all(as.numeric)

# Replace NA by average of each column
for (col in names(x_norm)) {
  x_norm[[col]][is.na(x_norm[[col]])] <- mean(x_norm[[col]], na.rm=TRUE)
}
```

Plot "normalized" features.

```{r}
#| fig-column: screen-inset
#| out-width: 100%
#| fig-width: 10
#| fig-height: 8
x_norm %>%
  pivot_longer(cols = everything()) %>%
  ggplot() +
  geom_histogram(aes(x = value), bins = 50) +
  facet_wrap(~name, scales = "free")
```

### Morphospace

#### Build

Let’s feed the features to a PCA to build a morphospace.

```{r}
# We need to use "scale.unit = TRUE" to center-scale all feature
m_space <- FactoMineR::PCA(x_norm, scale.unit = TRUE, graph = FALSE)
```

#### Eigenvalues

Plot the eigenvalues.

```{r}
eig <- m_space$eig %>%
  as.data.frame() %>%
  rownames_to_column(var = "comp") %>%
  as_tibble() %>%
  mutate(
    comp = str_remove(comp, "comp "),
    comp = as.numeric(comp),
    comp = as.factor(comp)
    ) %>% 
  rename(var = `percentage of variance`, cum_var = `cumulative percentage of variance`)

eig %>%
  ggplot() +
  geom_col(aes(x = comp, y = eigenvalue)) +
  geom_hline(yintercept = 1, col = "red", linewidth = 0.5) +
  theme_classic() +
  scale_y_continuous(expand = c(0, 0)) +
  labs(x = "PC", y = "Eigenvalue") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

Most of the variance is captured by the first three axes (`r format(eig$var[1]/100, digits = 2)`, `r format(eig$var[2]/100, digits = 2)` and `r format(eig$var[3]/100, digits = 2)`respectively).

Let’s plot this in log to have a better idea of PCs to select.

```{r}
eig %>%
  ggplot() +
  geom_path(aes(x = as.numeric(comp), y = eigenvalue)) +
  geom_point(aes(x = as.numeric(comp), y = eigenvalue)) +
  theme_classic() +
  scale_x_log10() +
  scale_y_log10() +
  labs(x = "PC", y = "Eigenvalue") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

[TODO: PC selection.]{style="color: red;"} See Numerical Ecology, p409

#### Features and axis definition

Let’s now plot the first two axes.

```{r}
#| fig-column: body-outset
#| out-width: 100%
plot(m_space, choix="var", axes = c(1, 2))
```

-   PC1: big objects in positive values, small objects in negative values.

-   PC2: clear (i.e. transparent) objects in positive values, dark (i.e. opaque) objects in negative values

As well as axes 3 and 4.

```{r}
#| fig-column: body-outset
#| out-width: 100%
plot(m_space, choix="var", axes = c(3, 4))
```

-   PC3: elongated objects in positive values, round objects in negative values
-   PC4: something with grey levels

#### Individuals

Let’s extract the coordinates of individuals in the morphospace.

```{r}
## Get coordinates of individuals
inds <- m_space$ind$coord %>% as_tibble()
# Set nice names for columns
colnames(inds) <- str_c("m_dim", paste(c(1:ncol(inds))))
# And join with initial dataframe of objects
o <- o %>%
  bind_cols(inds)
```

We can not plot the position of objects in the morphospace, coloured per profile.

```{r}
## Plot invidivuals with profile as colour
o %>%
  ggplot(aes(x = m_dim1, y = m_dim2, colour = profile_id)) +
  geom_point(show.legend = FALSE, size = 0.5, alpha = 0.05)
```

#### Tiling

Let’s now tile morphs within the morphological space.

```{r}
# Folder containing images
img_dir <- "~/Documents/Data/UVP5/images/"

# Number of features to select
n_feat <- 12

# Generate path to image
o <- o %>% mutate(path_to_img = str_c(img_dir, profile_id, "/", object_id, ".jpg"), .before = object_id) 

# Prepare a circle for the plot
circ <- circleFun(c(0, 0), 2, npoints = 500)


# Get variables contributions
#to select vars based on contribution to each plane
contribs <- as.data.frame(m_space$var$contrib)
colnames(contribs) <- str_c("m_dim", paste(c(1:ncol(contribs))))
contribs <- contribs %>% 
  rownames_to_column(var = "feature") %>% 
  as_tibble() %>% 
  mutate(
    m_dim_12 = abs(m_dim1) + abs(m_dim2),
    m_dim_23 = abs(m_dim2) + abs(m_dim3),
    m_dim_34 = abs(m_dim3) + abs(m_dim4)
  )


# List variables with higher contribution for plane 1:2
var_contrib_12 <- contribs %>% 
  arrange(desc(m_dim_12)) %>% 
  slice(1:n_feat) %>% 
  pull(feature)

# and for plane 3:4
var_contrib_34 <- contribs %>% 
  arrange(desc(m_dim_34)) %>% 
  slice(1:n_feat) %>% 
  pull(feature)

# Get types of features
feat_types <- read_csv("data/raw/features_qual.csv", show_col_types = FALSE)
# Set colour per type of feature, using a named vector
feat_colours <- brewer_colors(length(unique(feat_types$type)), "Set2") # pick the appropriate number of colours
names(feat_colours) <- sort(unique(feat_types$type)) # add names to colours

#homogenize scaling between individuals & variables for correct biplot
# Change scaling of variables/columns from scaling 1 to 2
var_scores <- as.data.frame(t(t(m_space$var$coord) / sqrt(m_space$eig[,1]))) # de-scale
var_scores_2 <- as.data.frame(t(t(var_scores) * sqrt(nrow(var_scores) * m_space$eig[,1]))) # re-scale
# Rename columns
colnames(var_scores_2) <- str_c("m_dim", paste(c(1:ncol(var_scores_2))))
# Add feature names 
var_scores_2 <- var_scores_2 %>% 
  rownames_to_column(var = "feature") %>% 
  as_tibble() %>% 
  # and types
  left_join(feat_types, by = join_by(feature))

# Compute length of projection to scale circle
var_scores_2 <- var_scores_2 %>% 
  mutate(
    len_12 = sqrt(m_dim1^2 + m_dim2^2),
    len_34 = sqrt(m_dim3^2 + m_dim4^2),
  )
```

Objects in morphospace for axes 1:2

```{r}
#| fig-column: body-outset
#| out-width: 100%
k <- max(var_scores_2$len_12) # adapt scaling of circle to fit the arrows
p12 <- ggmorph_tile(m_space, o$path_to_img, steps = 18, n_imgs = 3, fun = preprocess, dimensions = c(1,2), scale = 0.02) 
p12 + 
  geom_path(data = circ, aes(x = x*k, y = y*k), lty = 2, color = "grey", alpha = 0.7) + 
  geom_hline(yintercept = 0, color="grey", alpha = 0.9) +
  geom_vline(xintercept = 0, color="grey", alpha = 0.9) +
  geom_segment(data = var_scores_2 %>% filter(feature %in% var_contrib_12), aes(x = 0, xend = m_dim1, y = 0, yend = m_dim2, colour = type), arrow = arrow(length = unit(0.025, "npc"), type = "open")) +
  geom_text_repel(data = var_scores_2 %>% filter(feature %in% var_contrib_12), aes(x = m_dim1, y = m_dim2, label = feature, colour = type), show.legend = FALSE) +
  scale_colour_manual(values = feat_colours) +
  labs(colour = "Feature\ntype")
```

-   PC1 = size

-   PC2 = transparency

Objects in morphospace for axes 2:3

```{r}
#| fig-column: body-outset
#| out-width: 100%
k <- max(var_scores_2$len_34) # adapt scaling of circle to fit the arrows
p34 <- ggmorph_tile(m_space, o$path_to_img, steps = 18, n_imgs = 3, fun = preprocess, dimensions = c(3,4), scale = 0.02) 
p34 + 
  geom_path(data = circ, aes(x = x*k, y = y*k), lty = 2, color = "grey", alpha = 0.7) + 
  geom_hline(yintercept = 0, color="grey", alpha = 0.9) +
  geom_vline(xintercept = 0, color="grey", alpha = 0.9) +
  geom_segment(data = var_scores_2 %>% filter(feature %in% var_contrib_34), aes(x = 0, xend = m_dim3, y = 0, yend = m_dim4, colour = type), arrow = arrow(length = unit(0.025, "npc"), type = "open")) +
  geom_text_repel(data = var_scores_2 %>% filter(feature %in% var_contrib_34), aes(x = m_dim3, y = m_dim4, label = feature, colour = type), show.legend = FALSE) +
  scale_colour_manual(values = feat_colours) +
  labs(colour = "Feature\ntype")
```

-   PC3 = elongation

-   PC4 = heterogeneity of grey levels

### Diversity

#### Morphospace features

We can collect the position of objects in the morphospace to summarise the morphological diversity of each profile.

```{r}
# Compute mean and variance of dim1, dim2, dim3 and dim4 per profile
m_div_prof <- o %>% 
  group_by(profile_id, lon, lat) %>% 
  summarise(across(m_dim1:m_dim4, list(mean = mean, var = var))) %>% 
  ungroup()

# And store this with profiles data
profiles <- profiles %>% left_join(m_div_prof, by = join_by(profile_id, lon, lat))
```

And we can plot maps of mean `dim1` and `dim2` values for each profile.

```{r}
#| fig-column: body-outset
#| out-width: 100%
ggmap(
  profiles, 
  "m_dim1_mean", 
  type = "point", 
  palette = div_pal
  ) +
  labs(colour = "PC1\nSize")
```

```{r}
#| fig-column: body-outset
#| out-width: 100%
ggmap(
  profiles, 
  "m_dim2_mean", 
  type = "point", 
  palette = div_pal
  ) +
  labs(colour = "PC2\nTransparency")
```

```{r}
#| fig-column: body-outset
#| out-width: 100%
ggmap(
  profiles, 
  "m_dim3_mean", 
  type = "point", 
  palette = div_pal
  ) +
  labs(colour = "PC3\nElongation")
```

```{r}
#| fig-column: body-outset
#| out-width: 100%
ggmap(
  profiles, 
  "m_dim4_mean", 
  type = "point", 
  palette = div_pal
  ) +
  labs(colour = "PC4\nGrey hetero.")
```

We can also look at variance within profiles.

```{r}
#| fig-column: body-outset
#| out-width: 100%
ggmap(
  profiles, 
  "m_dim1_var", 
  type = "point"
  ) +
  labs(colour = "PC1 var\nSize")
```

```{r}
#| fig-column: body-outset
#| out-width: 100%
ggmap(
  profiles, 
  "m_dim2_var", 
  type = "point"
  ) +
  labs(colour = "PC2 var\nTransparency")
```

```{r}
#| fig-column: body-outset
#| out-width: 100%
ggmap(
  profiles, 
  "m_dim3_var", 
  type = "point"
  ) +
  labs(colour = "PC3 var\nElongation")
```

```{r}
#| fig-column: body-outset
#| out-width: 100%
ggmap(
  profiles, 
  "m_dim4_var", 
  type = "point"
  ) +
  labs(colour = "PC4 var\nGrey hetero.")
```

#### Metrics

Multivariate morphological diversity metrics have been defined in [Beck et al. 2023](https://royalsocietypublishing.org/doi/full/10.1098/rspb.2023.2109) following the definition of multivariate functional diversity metrics in [Villeger et al. 2008](https://esajournals.onlinelibrary.wiley.com/doi/full/10.1890/07-1206.1):

-   morphological richness

-   morphological evenness

-   morphological divergence

Computing these metrics require defining "morphs" (i.e. morphologically similar organisms) in the morphospace, i.e. using kmeans. These morphs are then used instead of species to compute morphological diversity metrics.

## Save

```{r}
save(profiles, file = "data/03.uvp_profiles.Rdata")
```
