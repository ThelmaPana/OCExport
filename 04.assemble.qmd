---
title: "Assemble POC, environmental and UVP data"
format:
  html:
    toc: true
editor: visual
---

## Load data

```{r}
#| label: load data
#| output: false
source("utils.R")

load("data/00.carbon_data.Rdata")
load("data/01.all_env.Rdata")
load("data/03.uvp_profiles.Rdata")
rm(coast)
```

## Round coordinates of env and UVP data to match carbon data

Carbon data is given on a 2°×2° grid, so we need to round env and UVP coordinates to match the same grid. Carbon longitudes are odd so we need to floor longitude with `precision = 2` and then add 1 to the result. Carbon latitudes are even so we can just round with `precision = 2`.

### Env data

```{r}
env <- env %>%
  arrange(lon, lat) %>%
  mutate(
    # floor longitude and add 1 because carbon longitudes are odd
    lon = roundp(lon, precision = 2, f = floor) + 1,
    # round latitude because carbon latitudes are even
    lat = roundp(lat, precision = 2, f = round)
  ) %>%
  # Average all values on carbon pixels
  group_by(lon, lat) %>%
  summarise_all(mean, na.rm = TRUE) %>%
  ungroup()
```

### UVP data

We can start by plotting a map of UVP profiles.

```{r}
profiles %>% 
  ggplot() +
  geom_polygon(data = world, aes(x = lon, y = lat, group = group), fill = "gray") +
  geom_point(aes(x = lon, y = lat), alpha = 0.5, size = 0.5) +
  coord_quickmap()
```

Now let’s round the coordinates and replot the map. We also need to average UVP data on our new grid, but before that let’s also compute the number of UVP profiles per carbon pixel.

```{r}
profiles <- profiles %>%
  # Drop profile identification
  select(-profile_id) %>% 
  mutate(
    # floor longitude and add 1 because carbon longitudes are odd
    lon = roundp(lon, precision = 2, f = floor) + 1,
    # round latitude because carbon latitudes are even
    lat = roundp(lat, precision = 2, f = round)
  )

n_profiles <- profiles %>% count(lon, lat)

profiles <- profiles %>% 
  # Average all values on carbon pixels
  group_by(lon, lat) %>%
  summarise_all(mean, na.rm = TRUE) %>%
  ungroup()

profiles %>% 
  ggplot() +
  geom_polygon(data = world, aes(x = lon, y = lat, group = group), fill = "gray") +
  geom_point(aes(x = lon, y = lat), alpha = 0.5, size = 0.5) +
  coord_quickmap()
```

UVP profiles are now aligned on the 2°×2° grid. We can also plot the number of UVP profiles per pixel.

```{r}
n_profiles %>% 
  ggplot() +
  geom_polygon(data = world, aes(x = lon, y = lat, group = group), fill = "gray") +
  geom_point(aes(x = lon, y = lat, alpha = n), size = 0.5) + 
  coord_quickmap()
```

We can notice a strong sampling in the California current and in the Peruvian upwelling.

Let’s have a quick look at Shannon diversity on this new grid.

```{r}
ggmap(profiles, "ta_shannon", type = "point")
```

## Assemble env, UVP and carbon data

Since all three datasets use the same round coordinates, we can join them together. As a result, we will only get env and carbon data where UVP data is available.

```{r}
df <- profiles %>%
  left_join(env,  by = join_by(lon, lat)) %>%
  left_join(df_c, by = join_by(lon, lat)) %>% 
  select(lon, lat, everything())
```

Our dataset contains `r nrow(df)` points.

Now, we can plot POC data at locations of UVP profiles.

```{r}
ggmap(df, "poc", type = "point")
```

Or temperature.

```{r}
ggmap(df, "temperature_mean", type = "point")
```

In both cases, we notice that some POC and temperature data is not available at some UVP locations.

```{r}
summary(df)
```

Let’s get rid of these points.

```{r}
df <- df %>% drop_na()
```

We still have `r nrow(df)` points in our dataset.

Let’s redraw our POC map.

```{r}
ggmap(df, "poc", type = "point")
```

## Subsample env variables

For now, just keep `mean` variables and ignore `sd` and `var` variables.

```{r}
#df <- df %>% select(-c(profile_id, lon, lat, datetime))
#df <- df %>% select(lon, lat, poc, contains("ta_"), contains("mean"))
```

## Save the resulting dataset

```{r}
save(df, file = file.path(data_dir, "04.all_data.Rdata"))
```
