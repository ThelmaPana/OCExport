---
title: "Assemble POC, environmental and UVP data"
author: "Thelma Panaïotis"
format:
  html:
    toc: true
    embed-resources: true
editor: visual
execute:
  cache: true
  warning: false
---

## Load data

```{r load_data}
#| label: load data
#| output: false
source("utils.R")

load("data/01.uvp_profiles.Rdata")
load("data/02.carbon_data.Rdata")
load("data/03.all_env.Rdata")
rm(coast)
```

## Round coordinates of env and UVP data to match carbon data

-   **Case 1: carbon data from Wang**

Carbon data is given on a 2°×2° grid, so we need to round env and UVP coordinates to match the same grid. Carbon longitudes are odd so we need to floor longitude with `precision = 2` and then add 1 to the result. Carbon latitudes are even so we can just round with `precision = 2`.

-   **Case 2: carbon data from Argo floats**

Carbon data is given on a 8°×4° grid, so we need to round env and UVP coordinates to match the same grid. Carbon longitudes are even so we need to round longitude with `precision = 8`. Carbon latitudes are even so we can just round with `precision = 4`.

-   **Case 3: carbon data from Sauzède**

Carbon data is given on a 0.25°×0.25° grid, so we need to round UVP coordinates to match the same grid. We need to floor longitude with `precision = 0.25` and then add 0.125 to the result. We need to floor latitude with `precision = 0.25` and then add 0.125 to the result.

```{r choose_c}
# Choose C data source
#c_data <- "wang"
#c_data <- "argo"
c_data <- "canyon"
if (c_data == "wang") {
  df_c <- df_c_mod
} else  if (c_data == "argo"){
  df_c <- df_c_argo
} else {
  df_c <- df_c_can
}
```

### Env data

Ignore env data if using POC from Sauzède because it is computed from the environment.

```{r round_env_coord}
if (c_data == "wang") {
  
  env <- env %>%
    arrange(lon, lat) %>%
    rowwise() %>% 
    mutate(
      # for wang, floor longitude and add 1 because carbon longitudes are odd
      lon = roundp(lon, precision = 2, f = floor) + 1,
      # for wang, round latitude because carbon latitudes are even
      lat = roundp(lat, precision = 2, f = round)
    ) %>%
    # Average all values on carbon pixels
    group_by(lon, lat) %>%
    summarise_all(mean, na.rm = TRUE) %>%
    ungroup()
  
} else  if (c_data == "argo"){
  
  env <- env %>%
    arrange(lon, lat) %>%
    rowwise() %>% 
    mutate(
      # for argo, round to 8°
      lon = roundp(lon, precision = 8, f = round),
      # for argo, round to 4°
      lat = roundp(lat, precision = 8, f = round)
    ) %>%
    # Average all values on carbon pixels
    group_by(lon, lat) %>%
    summarise_all(mean, na.rm = TRUE) %>%
    ungroup()
}
```

### UVP data

We can start by plotting a map of UVP profiles.

```{r map_uvp}
#| fig-column: body-outset
#| out-width: 100%
profiles %>% 
  ggplot() +
  geom_polygon(data = world, aes(x = lon, y = lat, group = group), fill = "gray") +
  geom_point(aes(x = lon, y = lat), alpha = 0.5, size = 0.5) +
  coord_quickmap()
```

Now let’s round the coordinates and replot the map. We also need to average UVP data on our new grid, but before that let’s also compute the number of UVP profiles per carbon pixel.

```{r round_uvp_coord}
#| fig-column: body-outset
#| out-width: 100%
if (c_data == "wang") {
  
  profiles_r <- profiles %>%
    # Drop profile identification
    select(-profile_id) %>% 
    arrange(lon, lat) %>%
    rowwise() %>% 
    mutate(
      # for wang, floor longitude and add 1 because carbon longitudes are odd
      lon = roundp(lon, precision = 2, f = floor) + 1,
      # for wang, round latitude because carbon latitudes are even
      lat = roundp(lat, precision = 2, f = round)
    ) %>%
    # Average all values on carbon pixels
    group_by(lon, lat) %>%
    summarise_all(mean, na.rm = TRUE) %>%
    ungroup()
  
} else  if (c_data == "argo"){
  
  profiles_r <- profiles %>%
    # Drop profile identification
    select(-profile_id) %>% 
    arrange(lon, lat) %>%
    rowwise() %>% 
    mutate(
      # for argo, round to 8°
      lon = roundp(lon, precision = 8, f = round),
      # for argo, round to 4°
      lat = roundp(lat, precision = 8, f = round)
    ) %>%
    # Average all values on carbon pixels
    group_by(lon, lat) %>%
    summarise_all(mean, na.rm = TRUE) %>%
    ungroup()
  
} else {
  
  profiles_r <- profiles %>%
    # Drop profile identification
    select(-profile_id) %>% 
    arrange(lon, lat) %>%
    rowwise() %>% 
    mutate(
      # for canyon, floor longitude at 0.25 and add 0.125
      lon = roundp(lon, precision = 0.25, f = floor) + 0.125,
      # for canyon, floor latitude at 0.25 and add 0.125
      lat = roundp(lat, precision = 0.25, f = floor) + 0.125
    ) %>%
    # Average all values on carbon pixels
    group_by(lon, lat) %>%
    summarise_all(mean, na.rm = TRUE) %>%
    ungroup()
}

n_profiles <- profiles_r %>% count(lon, lat)

profiles_r <- profiles_r %>% 
  # Average all values on carbon pixels
  group_by(lon, lat) %>%
  summarise_all(mean, na.rm = TRUE) %>%
  ungroup()

profiles_r %>% 
  ggplot() +
  geom_polygon(data = world, aes(x = lon, y = lat, group = group), fill = "gray") +
  geom_point(aes(x = lon, y = lat), alpha = 0.5, size = 0.5) +
  coord_quickmap()
```

UVP profiles are now aligned on the carbon grid. We can also plot the number of UVP profiles per pixel.

```{r map_uvp_gridded}
#| fig-column: body-outset
#| out-width: 100%
n_profiles %>% 
  ggplot() +
  geom_polygon(data = world, aes(x = lon, y = lat, group = group), fill = "gray") +
  geom_point(aes(x = lon, y = lat, alpha = n), size = 0.5) + 
  coord_quickmap()
```

Let’s have a quick look at Shannon diversity on this new grid.

```{r map_ta_ric}
#| fig-column: body-outset
#| out-width: 100%
ggmap(profiles_r, "ta_ric_1", type = "point")
```

## Assemble env, UVP and carbon data

Since all three datasets use the same round coordinates, we can join them together. As a result, we will only get env and carbon data where UVP data is available.

```{r assemple}
if (c_data == "canyon"){
  # If we use C data from Sauzède, do not include env
  df <- profiles_r %>%
    left_join(df_c, by = join_by(lon, lat)) %>% 
    select(lon, lat, everything())
} else {
  # Otherwise, include env
  df <- profiles_r %>%
    left_join(env,  by = join_by(lon, lat)) %>%
    left_join(df_c, by = join_by(lon, lat)) %>% 
    select(lon, lat, everything())
}
```

Our dataset contains `r nrow(df)` points.

Now, we can plot POC data at locations of UVP profiles.

```{r map_poc_uvp}
#| fig-column: body-outset
#| out-width: 100%
ggmap(df, "att", type = "point")
```

Or temperature.

```{r map_temp_uvp}
#| fig-column: body-outset
#| out-width: 100%
#ggmap(df, "temperature", type = "point", palette = scale_colour_cmocean(name = "thermal"))
```

In both cases, we notice that some POC and temperature data is not available at some UVP locations.

```{r summary}
summary(df)
```

Let’s get rid of these points.

```{r drop_na}
df <- df %>% drop_na()
```

We still have `r nrow(df)` points in our dataset.

Let’s redraw our POC map.

```{r map_poc_uvp_no_na}
#| fig-column: body-outset
#| out-width: 100%
ggmap(df, "att", type = "point")
```

## Save the resulting dataset

```{r save}
save(df, file = file.path(data_dir, "04.all_data.Rdata"))
```
